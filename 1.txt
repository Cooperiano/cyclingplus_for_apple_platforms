package com.example.cyclingplus.data.ai

import com.example.cyclingplus.data.db.AiAnalysisDao
import com.example.cyclingplus.data.db.AiAnalysisEntity
import com.example.cyclingplus.data.network.ChatCompletionRequest
import com.example.cyclingplus.data.network.ChatMessage
import com.example.cyclingplus.data.network.DeepSeekService
import com.example.cyclingplus.domain.model.RideStreamDataForAi
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.withContext
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository for DeepSeek AI analysis with caching and conversation support
 */
@Singleton
class DeepSeekRepository @Inject constructor(
    private val deepSeekService: DeepSeekService,
    private val aiAnalysisDao: AiAnalysisDao
) {

    /**
     * Get or analyze ride data - checks cache first, then calls API if needed
     * @param activityId Activity ID
     * @param apiKey DeepSeek API key
     * @param prompt Analysis prompt containing ride data
     * @param modelType Model to use (deepseek-chat or deepseek-reasoner)
     * @return AI-generated analysis text from cache or fresh API call
     */
    suspend fun getOrAnalyze(
        activityId: Long,
        apiKey: String,
        prompt: String,
        modelType: String = DeepSeekService.MODEL_CHAT
    ): Result<String> = withContext(Dispatchers.IO) {
        runCatching {
            // Check cache first
            val cachedAnalysis = aiAnalysisDao.getInitialAnalysis(activityId, modelType)
            if (cachedAnalysis != null) {
                return@runCatching cachedAnalysis.content
            }

            // No cache, call API
            val systemMessage = ChatMessage(
                role = "system",
                content = """
你是一位专业的骑行教练与运动生理数据分析专家，擅长通过功率、心率及训练负荷数据评估骑行表现，并提供个性化训练策略。
你的目标是生成系统化、专业但易懂的骑行训练分析报告。

分析报告需从以下方面展开（可根据数据完整性自动调整）：

---

### 一、训练强度评估
从以下指标评估训练强度是否合理：
- **平均功率（AP）** 与 **标准化功率（NP）**：反映实际输出与生理应激的差异。
- **心率分布区间**：统计各心率区间的时间比例，判断是否在目标训练区间内。
- **强度因子（IF）** = NP / FTP，用于衡量训练强度相对于能力上限的比例。
- **最大与平均心率比值**、**功率-心率漂移（Pa:Hr）**：评估耐力区间稳定性。
请指出训练是否过强、过弱或合理，并解释原因。

---

### 二、训练效果评估
从以下维度分析训练的效果与效率：
- **TSS（训练压力分数）**：综合训练强度与时长的负荷指数。
- **效率因子（EF）** = NP / 平均心率，衡量有氧效率。
- **功率曲线分析**（20min、5min、1min、30s）：识别短时与耐力能力的差异。
- 若数据支持，可引用 **CTL（长期负荷）**、**ATL（短期负荷）** 与 **TSB（训练平衡）** 判断状态趋势。

请在本节总结：
1. 本次训练主要刺激类型（耐力、有氧阈值、无氧或神经肌肉）；
2. 是否达成训练目标；
3. 长期趋势（提升、平台或疲劳）。

---

### 三、恢复与疲劳建议
结合近期训练负荷（TSS趋势或CTL/ATL关系），评估恢复需求：
- 当 **TSB < -10**：提示疲劳积累，需要主动恢复；
- 当 **TSB > +10**：表示恢复充分，可适度提高训练负荷；
- 若无TSB数据，可结合主观感受、睡眠与心率变异性（HRV）给出指导。

输出应包含：
- 建议恢复时间；
- 推荐恢复类型（完全休息 / 低强度骑行 / 交叉训练）；
- 简要说明恢复的科学依据。

---

### 四、改进与优化建议
基于数据发现的问题与表现趋势，提出针对性优化方向：
- **技术层面**：如踏频、功率平稳度（VI）、配速策略。
- **训练结构**：提升某区间能力（如Tempo、Sweet Spot或VO2max区间）。
- **功率分布优化**：是否存在功率过冲或分配不均。
- **节奏控制**：上坡与平路输出一致性。
- 若数据包含GPS，可对路线、海拔与风阻策略提出建议。

---

### 输出要求
- 使用 **结构化报告格式**（分标题与要点），语言 **专业但易懂**；
- 每个分析点需结合数据解释与训练意义；
- 尽量提供 **可执行建议**，避免笼统表达；
- 可用表格或条列清晰展示关键指标；
- 若数据不足，请明确说明限制并给出改进建议（例如“需增加功率计数据采样频率”）。

---
""".trimIndent()
            )

            val userMessage = ChatMessage(role = "user", content = prompt)

            val request = ChatCompletionRequest(
                model = modelType,
                messages = listOf(systemMessage, userMessage),
                temperature = 0.7,
                maxTokens = 2000
            )

            val response = deepSeekService.chatCompletion(
                authorization = "Bearer $apiKey",
                request = request
            )

            val analysis = response.choices.firstOrNull()?.message?.content
                ?: throw IllegalStateException("No response from DeepSeek API")

            // Save to cache
            val timestamp = System.currentTimeMillis()
            val entities = listOf(
                AiAnalysisEntity(
                    activityId = activityId,
                    role = "system",
                    content = systemMessage.content,
                    modelType = modelType,
                    timestamp = timestamp,
                    isInitialAnalysis = true
                ),
                AiAnalysisEntity(
                    activityId = activityId,
                    role = "user",
                    content = prompt,
                    modelType = modelType,
                    timestamp = timestamp,
                    isInitialAnalysis = true
                ),
                AiAnalysisEntity(
                    activityId = activityId,
                    role = "assistant",
                    content = analysis,
                    modelType = modelType,
                    timestamp = timestamp,
                    isInitialAnalysis = true
                )
            )
            aiAnalysisDao.insertAll(entities)

            analysis
        }
    }

    suspend fun evaluateTraining(
        apiKey: String,
        prompt: String,
        modelType: String = DeepSeekService.MODEL_CHAT
    ): Result<String> = withContext(Dispatchers.IO) {
        runCatching {
            val systemMessage = ChatMessage(
                role = "system",
                content = """
你是一位职业自行车教练与运动科学顾问。请基于用户提供的多场骑行训练数据，综合评估近期训练量、强度结构、能力变化与恢复状态，并生成结构化的中文报告。

报告需包含：
1. 训练量与强度趋势（近7天 vs 近28天，对比训练时间、距离、TSS/负荷、骑行频率）。
2. 能力与表现评估（有氧基础、阈值能力、无氧/冲刺能力、耐力稳定性等），指出优势与短板。
3. 疲劳与恢复建议（给出休息/主动恢复安排、识别过度训练风险、说明依据）。
4. 下一阶段训练指导（建议的周目标、重点训练课表/间歇、功率或心率区间、周期化安排）。
5. 数据完整性提醒：若发现数据缺口或异常，请说明可能影响并给出补充建议。

语言保持专业但易懂，段落清晰，可使用小标题和条列。务必引用关键数据支撑结论，并给出可执行的训练建议。
""".trimIndent()
            )

            val request = ChatCompletionRequest(
                model = modelType,
                messages = listOf(
                    systemMessage,
                    ChatMessage(role = "user", content = prompt)
                ),
                temperature = 0.6,
                maxTokens = 2200
            )

            val response = deepSeekService.chatCompletion(
                authorization = "Bearer $apiKey",
                request = request
            )

            response.choices.firstOrNull()?.message?.content
                ?: throw IllegalStateException("No response from DeepSeek API")
        }
    }

    /**
     * Executes a multi-turn conversation where each user message is sent in sequence
     * and the resulting assistant replies are fed back into the context.
     */
    suspend fun runConversation(
        apiKey: String,
        systemPrompt: String,
        userMessages: List<String>,
        modelType: String = DeepSeekService.MODEL_CHAT,
        temperature: Double = 0.6,
        maxTokens: Int = 2200
    ): Result<List<String>> = withContext(Dispatchers.IO) {
        runCatching {
            require(userMessages.isNotEmpty()) { "userMessages must not be empty" }

            val messages = mutableListOf(
                ChatMessage(role = "system", content = systemPrompt)
            )
            val outputs = mutableListOf<String>()

            for (content in userMessages) {
                messages += ChatMessage(role = "user", content = content)

                val request = ChatCompletionRequest(
                    model = modelType,
                    messages = messages,
                    temperature = temperature,
                    maxTokens = maxTokens
                )

                val response = deepSeekService.chatCompletion(
                    authorization = "Bearer $apiKey",
                    request = request
                )

                val assistantContent = response.choices.firstOrNull()?.message?.content
                    ?: throw IllegalStateException("No response from DeepSeek API")

                outputs += assistantContent
                messages += ChatMessage(role = "assistant", content = assistantContent)
            }

            outputs
        }
    }

    /**
     * Continue conversation with follow-up question
     * @param activityId Activity ID
     * @param userMessage User's follow-up question
     * @param apiKey DeepSeek API key
     * @param modelType Model to use
     * @return AI response
     */
    suspend fun continueConversation(
        activityId: Long,
        userMessage: String,
        apiKey: String,
        modelType: String = DeepSeekService.MODEL_CHAT
    ): Result<String> = withContext(Dispatchers.IO) {
        runCatching {
            // Load conversation history
            val history = aiAnalysisDao.getConversation(activityId, modelType)
            if (history.isEmpty()) {
                throw IllegalStateException("No conversation history found. Please analyze the ride first.")
            }

            // Build message list from history
            val messages = history.map { entity ->
                ChatMessage(role = entity.role, content = entity.content)
            } + ChatMessage(role = "user", content = userMessage)

            val request = ChatCompletionRequest(
                model = modelType,
                messages = messages,
                temperature = 0.7,
                maxTokens = 2000
            )

            val response = deepSeekService.chatCompletion(
                authorization = "Bearer $apiKey",
                request = request
            )

            val assistantResponse = response.choices.firstOrNull()?.message?.content
                ?: throw IllegalStateException("No response from DeepSeek API")

            // Save new messages to database
            val timestamp = System.currentTimeMillis()
            val newEntities = listOf(
                AiAnalysisEntity(
                    activityId = activityId,
                    role = "user",
                    content = userMessage,
                    modelType = modelType,
                    timestamp = timestamp,
                    isInitialAnalysis = false
                ),
                AiAnalysisEntity(
                    activityId = activityId,
                    role = "assistant",
                    content = assistantResponse,
                    modelType = modelType,
                    timestamp = timestamp,
                    isInitialAnalysis = false
                )
            )
            aiAnalysisDao.insertAll(newEntities)

            assistantResponse
        }
    }

    /**
     * Get conversation history as Flow
     */
    fun observeConversation(activityId: Long, modelType: String): Flow<List<AiAnalysisEntity>> {
        return aiAnalysisDao.observeConversation(activityId, modelType)
    }

    /**
     * Check if analysis cache exists for an activity
     */
    suspend fun hasCache(activityId: Long, modelType: String): Boolean = withContext(Dispatchers.IO) {
        aiAnalysisDao.hasCache(activityId, modelType)
    }

    /**
     * Delete conversation history for an activity
     */
    suspend fun clearConversation(activityId: Long) = withContext(Dispatchers.IO) {
        aiAnalysisDao.deleteByActivityId(activityId)
    }

    /**
     * Analyze ride data using DeepSeek AI (legacy method, kept for compatibility)
     * @param apiKey DeepSeek API key
     * @param prompt Analysis prompt containing ride data
     * @return AI-generated analysis text
     */
    @Deprecated("Use getOrAnalyze instead for caching support", ReplaceWith("getOrAnalyze(activityId, apiKey, prompt, modelType)"))
    suspend fun analyzeRide(apiKey: String, prompt: String): Result<String> = withContext(Dispatchers.IO) {
        runCatching {
            val request = ChatCompletionRequest(
                model = "deepseek-chat",
                messages = listOf(
                    ChatMessage(
                        role = "system",
                        content = """
你是一位专业的骑行教练与运动生理数据分析专家，擅长通过功率、心率及训练负荷数据评估骑行表现，并提供个性化训练策略。
你的目标是生成系统化、专业但易懂的骑行训练分析报告。

分析报告需从以下方面展开（可根据数据完整性自动调整）：

---

### 一、训练强度评估
从以下指标评估训练强度是否合理：
- **平均功率（AP）** 与 **标准化功率（NP）**：反映实际输出与生理应激的差异。
- **心率分布区间**：统计各心率区间的时间比例，判断是否在目标训练区间内。
- **强度因子（IF）** = NP / FTP，用于衡量训练强度相对于能力上限的比例。
- **最大与平均心率比值**、**功率-心率漂移（Pa:Hr）**：评估耐力区间稳定性。
请指出训练是否过强、过弱或合理，并解释原因。

---

### 二、训练效果评估
从以下维度分析训练的效果与效率：
- **TSS（训练压力分数）**：综合训练强度与时长的负荷指数。
- **效率因子（EF）** = NP / 平均心率，衡量有氧效率。
- **功率曲线分析**（20min、5min、1min、30s）：识别短时与耐力能力的差异。
- 若数据支持，可引用 **CTL（长期负荷）**、**ATL（短期负荷）** 与 **TSB（训练平衡）** 判断状态趋势。

请在本节总结：
1. 本次训练主要刺激类型（耐力、有氧阈值、无氧或神经肌肉）；
2. 是否达成训练目标；
3. 长期趋势（提升、平台或疲劳）。

---

### 三、恢复与疲劳建议
结合近期训练负荷（TSS趋势或CTL/ATL关系），评估恢复需求：
- 当 **TSB < -10**：提示疲劳积累，需要主动恢复；
- 当 **TSB > +10**：表示恢复充分，可适度提高训练负荷；
- 若无TSB数据，可结合主观感受、睡眠与心率变异性（HRV）给出指导。

输出应包含：
- 建议恢复时间；
- 推荐恢复类型（完全休息 / 低强度骑行 / 交叉训练）；
- 简要说明恢复的科学依据。

---

### 四、改进与优化建议
基于数据发现的问题与表现趋势，提出针对性优化方向：
- **技术层面**：如踏频、功率平稳度（VI）、配速策略。
- **训练结构**：提升某区间能力（如Tempo、Sweet Spot或VO2max区间）。
- **功率分布优化**：是否存在功率过冲或分配不均。
- **节奏控制**：上坡与平路输出一致性。
- 若数据包含GPS，可对路线、海拔与风阻策略提出建议。

---

### 输出要求
- 使用 **结构化报告格式**（分标题与要点），语言 **专业但易懂**；
- 每个分析点需结合数据解释与训练意义；
- 尽量提供 **可执行建议**，避免笼统表达；
- 可用表格或条列清晰展示关键指标；
- 若数据不足，请明确说明限制并给出改进建议（例如“需增加功率计数据采样频率”）。

---
""".trimIndent()
                    ),
                    ChatMessage(
                        role = "user",
                        content = prompt
                    )
                ),
                temperature = 0.7,
                maxTokens = 2000
            )

            val response = deepSeekService.chatCompletion(
                authorization = "Bearer $apiKey",
                request = request
            )

            val analysis = response.choices.firstOrNull()?.message?.content
                ?: throw IllegalStateException("No response from DeepSeek API")

            analysis
        }
    }

    /**
     * Build analysis prompt from ride data
     */
    fun buildPrompt(
        activityName: String?,
        distance: Double?,
        duration: Int?,
        elevationGain: Double?,
        avgPower: Double?,
        avgHeartRate: Double?,
        avgCadence: Double?,
        normalizedPower: Double?,
        intensityFactor: Double?,
        trainingStressScore: Double?,
        variabilityIndex: Double?,
        efficiencyFactor: Double?,
        heartRateZones: Map<String, Long>?,
        powerZones: Map<String, Long>?,
        streamData: RideStreamDataForAi? = null,
        riderWeightKg: Double? = null,
        bikeWeightKg: Double? = null,
        riderHeightCm: Double? = null,
        bodyFatPercentage: Double? = null,
        bikeModel: String? = null
    ): String {
        val sb = StringBuilder()
        sb.appendLine("请分析以下骑行数据:")
        sb.appendLine()

        // 骑手信息
        if (riderWeightKg != null || riderHeightCm != null || bodyFatPercentage != null) {
            sb.appendLine("骑手信息:")
            riderWeightKg?.let { sb.appendLine("  体重: ${String.format("%.1f", it)} kg") }
            riderHeightCm?.let { if (it > 0) sb.appendLine("  身高: ${String.format("%.0f", it)} cm") }
            bodyFatPercentage?.let { if (it > 0) sb.appendLine("  体脂率: ${String.format("%.1f", it)}%") }
            riderWeightKg?.let { weight ->
                riderHeightCm?.let { height ->
                    if (height > 0) {
                        val bmi = weight / ((height / 100) * (height / 100))
                        sb.appendLine("  BMI: ${String.format("%.1f", bmi)}")
                    }
                }
            }
            sb.appendLine()
        }

        // 车辆信息
        if (bikeWeightKg != null || bikeModel != null) {
            sb.appendLine("车辆信息:")
            bikeModel?.let { if (it.isNotEmpty()) sb.appendLine("  型号: $it") }
            bikeWeightKg?.let { sb.appendLine("  重量: ${String.format("%.1f", it)} kg") }
            if (riderWeightKg != null && bikeWeightKg != null) {
                val total = riderWeightKg + bikeWeightKg
                sb.appendLine("  总重: ${String.format("%.1f", total)} kg (骑手+车辆)")
            }
            sb.appendLine()
        }

        // 基本信息
        activityName?.let { sb.appendLine("活动名称: $it") }
        distance?.let { sb.appendLine("距离: ${String.format("%.2f", it / 1000)} 公里") }
        duration?.let { 
            val hours = it / 3600
            val minutes = (it % 3600) / 60
            sb.appendLine("时长: ${hours}小时${minutes}分钟")
        }
        elevationGain?.let { sb.appendLine("爬升: ${String.format("%.0f", it)} 米") }
        sb.appendLine()

        // 功率数据
        if (avgPower != null || normalizedPower != null) {
            sb.appendLine("功率数据:")
            avgPower?.let { sb.appendLine("  平均功率: ${String.format("%.0f", it)} W") }
            normalizedPower?.let { sb.appendLine("  标准化功率(NP): ${String.format("%.0f", it)} W") }
            variabilityIndex?.let { sb.appendLine("  变异指数(VI): ${String.format("%.2f", it)}") }
            sb.appendLine()
        }

        // 心率数据
        avgHeartRate?.let {
            sb.appendLine("心率数据:")
            sb.appendLine("  平均心率: ${String.format("%.0f", it)} bpm")
            sb.appendLine()
        }

        // 训练指标
        if (intensityFactor != null || trainingStressScore != null || efficiencyFactor != null) {
            sb.appendLine("训练指标:")
            intensityFactor?.let { sb.appendLine("  强度因子(IF): ${String.format("%.2f", it)}") }
            trainingStressScore?.let { sb.appendLine("  训练压力分数(TSS): ${String.format("%.0f", it)}") }
            efficiencyFactor?.let { sb.appendLine("  效率因子(EF): ${String.format("%.2f", it)}") }
            sb.appendLine()
        }

        // 功率区间分布
        if (!powerZones.isNullOrEmpty()) {
            sb.appendLine("功率区间分布:")
            powerZones.forEach { (zone, seconds) ->
                val minutes = seconds / 60
                val percentage = if (duration != null && duration > 0) {
                    (seconds.toDouble() / duration * 100)
                } else 0.0
                sb.appendLine("  $zone: ${minutes}分钟 (${String.format("%.1f", percentage)}%)")
            }
            sb.appendLine()
        }

        // 心率区间分布
        if (!heartRateZones.isNullOrEmpty()) {
            sb.appendLine("心率区间分布:")
            heartRateZones.forEach { (zone, seconds) ->
                val minutes = seconds / 60
                val percentage = if (duration != null && duration > 0) {
                    (seconds.toDouble() / duration * 100)
                } else 0.0
                sb.appendLine("  $zone: ${minutes}分钟 (${String.format("%.1f", percentage)}%)")
            }
            sb.appendLine()
        }

        // 踏频
        avgCadence?.let {
            sb.appendLine("平均踏频: ${String.format("%.0f", it)} rpm")
            sb.appendLine()
        }

        // 详细流数据（如果有）
        if (streamData != null && streamData.dataPoints.isNotEmpty()) {
            sb.appendLine("=" .repeat(50))
            sb.appendLine("详细骑行数据 (每秒采样，全量点位)")
            sb.appendLine("采样点总数: ${streamData.originalSampleCount}, 已包含: ${streamData.includedSampleCount}")
            sb.appendLine("=" .repeat(50))
            sb.appendLine()
            
            // 使用 CSV 格式，更易于 AI 理解
            sb.appendLine(streamData.toCsv())
            sb.appendLine()
            sb.appendLine("=" .repeat(50))
            sb.appendLine()
            
            sb.appendLine("""
                |基于以上详细数据，请分析：
                |1. 功率输出的稳定性和波动情况
                |2. 心率响应与功率输出的匹配度
                |3. 爬坡和平路的功率/心率表现差异
                |4. 疲劳点的识别（功率下降、心率持续高位等）
                |5. 配速策略是否合理（起始、中段、冲刺）
                |6. 具体的改进建议（基于数据中的具体时间段）
            """.trimMargin())
            sb.appendLine()
        }

        sb.appendLine("请根据以上数据提供专业的分析和建议。")

        return sb.toString()
    }
}
#####
package com.example.cyclingplus.domain.model

/**
 * High-resolution ride stream data prepared for AI analysis.
 * Contains per-sample time-series data points with key metrics.
 */
data class RideStreamDataForAi(
    /** List of data points included in the payload */
    val dataPoints: List<DataPoint>,
    
    /** Available metrics in this dataset */
    val availableMetrics: Set<String>,
    
    /** Original sample count before downsampling */
    val originalSampleCount: Int,
    
    /** Number of samples included in the payload (may equal original count) */
    val includedSampleCount: Int,
    
    /** Activity duration in seconds */
    val durationSeconds: Int
) {
    
    /**
     * Single data point at a specific time
     */
    data class DataPoint(
        /** Elapsed time in seconds */
        val timeSeconds: Int,
        
        /** Power in watts (null if not available) */
        val powerWatts: Int?,
        
        /** Heart rate in bpm (null if not available) */
        val heartRateBpm: Int?,
        
        /** Speed in m/s (null if not available) */
        val speedMps: Double?,
        
        /** Altitude in meters (null if not available) */
        val altitudeMeters: Double?,
        
        /** Cadence in rpm (null if not available) */
        val cadenceRpm: Int?,
        
        /** Grade/slope in percentage (null if not available) */
        val gradePercent: Double?
    )
    
    /**
     * Format as CSV string for AI prompt
     */
    fun toCsv(): String {
        val sb = StringBuilder()
        
        // Header
        val headers = mutableListOf("时间(秒)")
        if (availableMetrics.contains("power")) headers.add("功率(W)")
        if (availableMetrics.contains("heartrate")) headers.add("心率(bpm)")
        if (availableMetrics.contains("speed")) headers.add("速度(m/s)")
        if (availableMetrics.contains("altitude")) headers.add("海拔(m)")
        if (availableMetrics.contains("cadence")) headers.add("踏频(rpm)")
        if (availableMetrics.contains("grade")) headers.add("坡度(%)")

        sb.appendLine(headers.joinToString(","))
        
        // Data rows
        dataPoints.forEach { point ->
            val values = mutableListOf<String>()
            values.add(point.timeSeconds.toString())
            
            if (availableMetrics.contains("power")) {
                values.add(point.powerWatts?.toString() ?: "")
            }
            if (availableMetrics.contains("heartrate")) {
                values.add(point.heartRateBpm?.toString() ?: "")
            }
            if (availableMetrics.contains("speed")) {
                values.add(point.speedMps?.let { String.format("%.2f", it) } ?: "")
            }
            if (availableMetrics.contains("altitude")) {
                values.add(point.altitudeMeters?.let { String.format("%.1f", it) } ?: "")
            }
            if (availableMetrics.contains("cadence")) {
                values.add(point.cadenceRpm?.toString() ?: "")
            }
            if (availableMetrics.contains("grade")) {
                values.add(point.gradePercent?.let { String.format("%.1f", it) } ?: "")
            }
            
            sb.appendLine(values.joinToString(","))
        }
        
        return sb.toString()
    }
    
    /**
     * Format as compact JSON string for AI prompt
     */
    fun toCompactJson(): String {
        val sb = StringBuilder()
        sb.append("[")
        
        dataPoints.forEachIndexed { index, point ->
            if (index > 0) sb.append(",")
            sb.append("{")
            sb.append("\"t\":${point.timeSeconds}")
            
            point.powerWatts?.let { sb.append(",\"p\":$it") }
            point.heartRateBpm?.let { sb.append(",\"hr\":$it") }
            point.speedMps?.let { sb.append(",\"s\":${String.format("%.2f", it)}") }
            point.altitudeMeters?.let { sb.append(",\"alt\":${String.format("%.1f", it)}") }
            point.cadenceRpm?.let { sb.append(",\"cad\":$it") }
            point.gradePercent?.let { sb.append(",\"g\":${String.format("%.1f", it)}") }
            
            sb.append("}")
        }
        
        sb.append("]")
        return sb.toString()
    }
}
#####
package com.example.cyclingplus.domain.usecase

import com.example.cyclingplus.data.ai.DeepSeekRepository
import com.example.cyclingplus.data.db.AiAnalysisEntity
import com.example.cyclingplus.data.db.StravaActivityEntity
import com.example.cyclingplus.data.network.DeepSeekService
import com.example.cyclingplus.data.strava.StravaRepository
import com.example.cyclingplus.domain.model.AnalysisSummary
import com.example.cyclingplus.domain.preferences.PerformancePreferences
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Use case for analyzing rides with DeepSeek AI, with caching and conversation support
 */
@Singleton
class AnalyzeRideWithAiUseCase @Inject constructor(
    private val deepSeekRepository: DeepSeekRepository,
    private val stravaRepository: StravaRepository,
    private val performancePreferences: PerformancePreferences
) {

    /**
     * Analyze a ride activity with AI (with cache-first strategy)
     * @param apiKey DeepSeek API key
     * @param activity Strava activity entity
     * @param analysisSummary Optional detailed analysis summary
     * @param modelType Model to use (deepseek-chat or deepseek-reasoner)
     * @param includeStreamData Whether to include detailed stream data (default: true)
     * @return Result containing AI analysis text or error
     */
    suspend fun analyze(
        apiKey: String,
        activity: StravaActivityEntity,
        analysisSummary: AnalysisSummary? = null,
        modelType: String = DeepSeekService.MODEL_CHAT,
        includeStreamData: Boolean = true
    ): Result<String> {
        if (apiKey.isBlank()) {
            return Result.failure(IllegalArgumentException("DeepSeek API key is required"))
        }

        // Get stream data if requested
        val streamData = if (includeStreamData) {
            runCatching { stravaRepository.getStreamDataForAi(activity.id) }.getOrNull()
        } else {
            null
        }

        val prompt = buildAnalysisPrompt(activity, analysisSummary, streamData)
        return deepSeekRepository.getOrAnalyze(activity.id, apiKey, prompt, modelType)
    }

    /**
     * Continue conversation with follow-up question
     * @param activityId Activity ID
     * @param userMessage User's follow-up question
     * @param apiKey DeepSeek API key
     * @param modelType Model to use
     * @return Result containing AI response or error
     */
    suspend fun continueConversation(
        activityId: Long,
        userMessage: String,
        apiKey: String,
        modelType: String = DeepSeekService.MODEL_CHAT
    ): Result<String> {
        if (apiKey.isBlank()) {
            return Result.failure(IllegalArgumentException("DeepSeek API key is required"))
        }
        if (userMessage.isBlank()) {
            return Result.failure(IllegalArgumentException("Message cannot be empty"))
        }

        return deepSeekRepository.continueConversation(activityId, userMessage, apiKey, modelType)
    }

    /**
     * Observe conversation history as Flow
     */
    fun observeConversation(activityId: Long, modelType: String): Flow<List<AiAnalysisEntity>> {
        return deepSeekRepository.observeConversation(activityId, modelType)
    }

    /**
     * Check if analysis cache exists
     */
    suspend fun hasCache(activityId: Long, modelType: String): Boolean {
        return deepSeekRepository.hasCache(activityId, modelType)
    }

    /**
     * Clear conversation history
     */
    suspend fun clearConversation(activityId: Long) {
        deepSeekRepository.clearConversation(activityId)
    }

    /**
     * Build analysis prompt from activity data
     */
    private suspend fun buildAnalysisPrompt(
        activity: StravaActivityEntity,
        analysisSummary: AnalysisSummary?,
        streamData: com.example.cyclingplus.domain.model.RideStreamDataForAi? = null
    ): String {
        // Get user profile data
        val riderWeight = performancePreferences.getRiderWeightKg()
        val bikeWeight = performancePreferences.getBikeWeightKg()
        val riderHeight = performancePreferences.getRiderHeightCm()
        val bodyFat = performancePreferences.getBodyFatPercentage()
        val bikeModel = performancePreferences.getBikeModel()
        
        return if (analysisSummary != null) {
            // 使用详细的分析数据
            deepSeekRepository.buildPrompt(
                activityName = activity.name,
                distance = activity.distanceMeters,
                duration = activity.movingTimeSec,
                elevationGain = activity.elevationGain,
                avgPower = activity.avgWatts,
                avgHeartRate = activity.avgHr,
                avgCadence = analysisSummary.averageCadence,
                normalizedPower = analysisSummary.metrics.normalizedPower,
                intensityFactor = analysisSummary.metrics.intensityFactor,
                trainingStressScore = analysisSummary.metrics.trainingStressScore,
                variabilityIndex = analysisSummary.metrics.variabilityIndex,
                efficiencyFactor = analysisSummary.metrics.efficiencyFactor,
                heartRateZones = analysisSummary.metrics.heartRateZoneSeconds,
                powerZones = analysisSummary.metrics.powerZoneSeconds,
                streamData = streamData,
                riderWeightKg = riderWeight,
                bikeWeightKg = bikeWeight,
                riderHeightCm = if (riderHeight > 0) riderHeight else null,
                bodyFatPercentage = if (bodyFat > 0) bodyFat else null,
                bikeModel = if (bikeModel.isNotEmpty()) bikeModel else null
            )
        } else {
            // 仅使用基本活动数据
            deepSeekRepository.buildPrompt(
                activityName = activity.name,
                distance = activity.distanceMeters,
                duration = activity.movingTimeSec,
                elevationGain = activity.elevationGain,
                avgPower = activity.avgWatts,
                avgHeartRate = activity.avgHr,
                avgCadence = null,
                normalizedPower = null,
                intensityFactor = null,
                trainingStressScore = null,
                variabilityIndex = null,
                efficiencyFactor = null,
                heartRateZones = null,
                powerZones = null,
                streamData = streamData,
                riderWeightKg = riderWeight,
                bikeWeightKg = bikeWeight,
                riderHeightCm = if (riderHeight > 0) riderHeight else null,
                bodyFatPercentage = if (bodyFat > 0) bodyFat else null,
                bikeModel = if (bikeModel.isNotEmpty()) bikeModel else null
            )
        }
    }
}
